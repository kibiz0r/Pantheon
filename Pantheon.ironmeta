using System;
using System.Linq.Expressions;

ironmeta Pantheon<char, Expression> : IronMeta.Matcher.CharMatcher<Expression, _Pantheon_Item>
{
    // Basic Rules
    Terminal = ~. | Whitespace | Operator | "Terminal";
    Digit = .:n ?(n >= '0' && n <= '9');
    Number = NumberWithDecimal | WholeNumber;
    WholeNumber = '-'? Digit+;
    NumberWithDecimal = '-'? Digit* '.' Digit+;
    Character = :c ?(c >= 'A' && c <= 'z');
    Whitespace = ' ';

    // Operators
    Plus = '+';
    Asterisk = '*';
    Operator = Plus | Asterisk;

    // Numeric Literals
    LongSuffix = 'l' | 'L';
    FloatSuffix = 'f' | 'F';

    IntegerLiteral = WholeNumber:n &Terminal -> { return Expression.Constant(int.Parse(n.Text())); };
    LongLiteral = WholeNumber:n LongSuffix &Terminal -> { return Expression.Constant(long.Parse(n.Text())); };
    FloatLiteral = Number:n FloatSuffix &Terminal -> { return Expression.Constant(float.Parse(n.Text())); };
    DoubleLiteral = NumberWithDecimal:n &Terminal -> { return Expression.Constant(double.Parse(n.Text())); };

    NumericLiteral = IntegerLiteral | LongLiteral | FloatLiteral | DoubleLiteral;

    // TimeSpan Literals
    DaysSuffix = 'd' | 'D';
    MinutesSuffix = 'm' | 'M';
    SecondsSuffix = 's' | 'S';
    MillisecondsSuffix = "ms" | "MS";

    DaysLiteral = Number:n DaysSuffix &Terminal -> { return Expression.Constant(TimeSpan.FromDays(double.Parse(n.Text()))); };
    MinutesLiteral = Number:n MinutesSuffix &Terminal -> { return Expression.Constant(TimeSpan.FromMinutes(double.Parse(n.Text()))); };
    SecondsLiteral = Number:n SecondsSuffix &Terminal -> { return Expression.Constant(TimeSpan.FromSeconds(double.Parse(n.Text()))); };
    MillisecondsLiteral = Number:n MillisecondsSuffix &Terminal -> { return Expression.Constant(TimeSpan.FromMilliseconds(double.Parse(n.Text()))); };

    TimeSpanLiteral = DaysLiteral | MinutesLiteral | SecondsLiteral | MillisecondsLiteral;

    Literal = NumericLiteral | TimeSpanLiteral;

    // IntegerExpr :type = type:expr ?(expr != null && expr.IsExpressionOf<int>())
                      // | IntegerLiteral;
    // LongExpr = IntegerExpr:expr -> { return Expression.Convert(expr, typeof(long)); }
             // | LongLiteral;
    // FloatExpr = (IntegerExpr | LongExpr):expr -> { return Expression.Convert(expr, typeof(float)); }
              // | Expr:expr ?(expr != null && expr.IsExpressionOf<float>())
              // | FloatLiteral;
    // DoubleExpr = (IntegerExpr | FloatExpr):expr -> { return Expression.Convert(expr, typeof(double)); }
               // | Expr:expr ?(expr != null && expr.IsExpressionOf<double>())
               // | DoubleLiteral;
    // TimeSpanExpr = Expr:expr ?(expr != null && expr.IsExpressionOf<TimeSpan>())
                 // | TimeSpanLiteral;

    // Binary Expressions
    // Add :type = type:left Whitespace* Plus Whitespace* type:right -> { return Expression.AddChecked(left, right); };
    // Add = Expr:left Whitespace* Plus Whitespace* Expr:right ?(left.Expression().Type == right.Expression().Type) -> { return Expression.AddChecked(left, right); };
    // Add = (Add | Multiply):left Whitespace* Plus Whitespace* (Add | Multiply):right ?(left.Expression().Type == right.Expression().Type) -> { return Expression.AddChecked(left, right); };
    // Add = Add(IntegerLiteral):left Whitespace* Plus Whitespace* Add(IntegerLiteral):right -> { return Expression.AddChecked(left, right); }
        // | Add(LongLiteral):left Whitespace* Plus Whitespace* Add(LongLiteral):right -> { return Expression.AddChecked(left, right); }
        // | Add(FloatLiteral):left Whitespace* Plus Whitespace* Add(FloatLiteral):right -> { return Expression.AddChecked(left, right); }
        // | Add(DoubleLiteral):left Whitespace* Plus Whitespace* Add(DoubleLiteral):right -> { return Expression.AddChecked(left, right); };
    // Add :type = Multiply(type):left Whitespace* Plus Whitespace* Add(type):right -> { return Expression.AddChecked(left, right); }
              // | Multiply(type);

    // Multiply = Multiply(IntegerExpr):left Whitespace* Asterisk Whitespace* Multiply(IntegerExpr):right -> { return Expression.MultiplyChecked(left, right); }
             // | Multiply(LongExpr):left Whitespace* Asterisk Whitespace* Multiply(LongExpr):right -> { return Expression.MultiplyChecked(left, right); }
             // | Multiply(FloatExpr):left Whitespace* Asterisk Whitespace* Multiply(FloatExpr):right -> { return Expression.MultiplyChecked(left, right); }
             // | Multiply(DoubleExpr):left Whitespace* Asterisk Whitespace* Multiply(DoubleExpr):right -> { return Expression.MultiplyChecked(left, right); };
    // Multiply :type = type:left Whitespace* Asterisk Whitespace* Multiply(type):right -> { return Expression.MultiplyChecked(left, right); }
                   // | type;

    Add :type = Multiply(type):left Whitespace* Plus Whitespace* Add(type):right -> { return Expression.Add(left, right); }
              | Multiply(type):left Whitespace* Plus Whitespace* Multiply(type):right -> { return Expression.Add(left, right); };
    Multiply :type = type:left Whitespace* Asterisk Whitespace* Multiply(type):right -> { return Expression.Multiply(left, right); }
                   | type;

    IntegerExpr = IntegerLiteral;
    LongExpr = LongLiteral
             | IntegerLiteral:lit -> { return Expression.Convert(lit, typeof(long)); };
    FloatExpr = FloatLiteral
              | (IntegerLiteral | LongLiteral):lit -> { return Expression.Convert(lit, typeof(float)); };
    DoubleExpr = DoubleLiteral
               | (IntegerLiteral | LongLiteral | FloatLiteral):lit -> { return Expression.Convert(lit, typeof(double)); };

    Expr = Add(IntegerExpr) | Add(LongExpr) | Add(FloatExpr) | Add(DoubleExpr) | Multiply(IntegerExpr) | Literal;
}
